<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synchronized Audiobook Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, serverTimestamp, runTransaction, getDocs, where, limit, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Firebase Configuration ---
        // The __firebase_config and __app_id variables are automatically provided 
        // when running within the Canvas/Immersive environment.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        
        // --- ⚠️ IMPORTANT: FOR EXTERNAL HOSTING (like GitHub Pages) ⚠️ ---
        // You MUST replace the placeholder values in EXTERNAL_FIREBASE_CONFIG below 
        // with your actual Firebase Project credentials (get them from the Firebase Console).
        // NOTE: The user has indicated that they have provided the correct keys for their deployment.
        const EXTERNAL_FIREBASE_CONFIG = {
        apiKey: "AIzaSyC7eitj-tb2mHofXyJEHaegvNu_7EgXxxw",
        authDomain: "audiobookschoolofarhuron.firebaseapp.com",
        projectId: "audiobookschoolofarhuron",
        storageBucket: "audiobookschoolofarhuron.firebasestorage.app",
        messagingSenderId: "771527529225",
        appId: "1:771527529225:web:4f46a5bcc8008582e579d8"
        };

        const configToUse = firebaseConfig || EXTERNAL_FIREBASE_CONFIG;
        
        let app;
        let db;
        let auth;
        let userId;
        let player;
        
        let playerStateRef;
        let usersRef;
        let currentUserRef;

        let isReady = false; // Local state for the ready button
        const READY_THRESHOLD_PERCENTAGE = 0.5; // 50% required
        const INACTIVITY_TIMEOUT_MS = 15000; // 15 seconds for presence heartbeat

        // --- Utility Functions ---
        function getElement(id) {
            return document.getElementById(id);
        }

        function logError(message) {
            console.error(message);
            // Instead of using alert(), update the UI with a custom message box
            const messageBox = getElement('messageBox');
            messageBox.innerHTML = `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">${message}</div>`;
        }

        function logStatus(message, isError = false) {
            console.log(message);
            const statusText = getElement('statusText');
            statusText.textContent = message;
            statusText.className = isError 
                ? 'text-red-600 font-semibold' 
                : 'text-green-600 font-semibold';
        }

        // --- Firebase Initialization and Authentication ---

        async function initializeApp() {
            // Check if configuration is valid (specifically looking for the placeholder to trigger error)
            if (!configToUse || !configToUse.projectId || configToUse.projectId.includes("YOUR_PASTED")) {
                logError("CRITICAL: Firebase configuration is missing or invalid. Please update EXTERNAL_FIREBASE_CONFIG.");
                return;
            }

            try {
                app = initializeApp(configToUse);
                db = getFirestore(app);
                auth = getAuth(app);

                // Sign in anonymously if no custom token is provided
                // This ensures we always have a userId
                await signInAnonymously(auth);
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        // Display the full ID immediately upon successful auth
                        getElement('userIdDisplay').textContent = userId; 
                        logStatus(`Authenticated: User ID ${userId.substring(0, 8)}...`);
                        
                        // Set up Firestore references and listeners
                        setupFirestoreReferences();
                        setupFirestoreListener();
                        monitorUserPresence(); 
                        listenToReadyStatus();
                        
                    } else {
                        logStatus("Authentication failed. Retrying anonymously.", true);
                        signInAnonymously(auth);
                    }
                });
            } catch (error) {
                logError(`Firebase Init Error: ${error.message}`);
            }
        }

        function setupFirestoreReferences() {
            // Document for synchronization state (Public Data)
            const playerStateDocPath = `artifacts/${appId}/public/data/audiobook_player_state/state`;
            playerStateRef = doc(db, playerStateDocPath);

            // Collection for tracking user presence and readiness (Public Data)
            const usersCollectionPath = `artifacts/${appId}/public/data/audiobook_users`;
            usersRef = collection(db, usersCollectionPath);
            
            // Document for the current user's presence/ready status
            currentUserRef = doc(db, usersCollectionPath, auth.currentUser.uid);
        }

        // --- User Presence and Readiness ---

        /**
         * Updates the current user's lastSeen timestamp and isReady status in Firestore.
         */
        function monitorUserPresence() {
            const updatePresence = () => {
                setDoc(currentUserRef, {
                    isReady: isReady,
                    lastSeen: serverTimestamp()
                }, { merge: true })
                .catch(err => console.error("Error updating user presence:", err));
            };

            // Initial write
            updatePresence(); 
            // Heartbeat update every few seconds
            setInterval(updatePresence, INACTIVITY_TIMEOUT_MS / 3); 
        }

        /**
         * Listens to all user documents to calculate total active and ready users.
         */
        function listenToReadyStatus() {
            // Calculate cutoff timestamp for active users (now - timeout)
            const cutoff = new Date(Date.now() - INACTIVITY_TIMEOUT_MS);
            
            // Query users who have been seen recently
            // Note: Firestore doesn't allow 'where' queries on serverTimestamp fields directly for dynamic checks
            // So we'll fetch the whole collection and filter/sort client-side for "lastSeen"
            // For simplicity and to avoid index issues, we listen to all user docs and filter by the timestamp client-side.
            
            onSnapshot(usersRef, (snapshot) => {
                const activeUsers = [];
                let readyCount = 0;
                
                snapshot.forEach(userDoc => {
                    const data = userDoc.data();
                    const lastSeenMs = data.lastSeen ? data.lastSeen.toMillis() : 0;
                    
                    // Filter: Only count users seen in the last 15 seconds
                    if (lastSeenMs >= cutoff.getTime()) {
                        activeUsers.push(userDoc.id);
                        if (data.isReady) {
                            readyCount++;
                        }
                    }
                });
                
                const totalActiveUsers = activeUsers.length;
                const requiredReadyCount = Math.ceil(totalActiveUsers * READY_THRESHOLD_PERCENTAGE);
                
                // Update UI display
                getElement('readyStatus').textContent = `Ready: ${readyCount} / ${totalActiveUsers}`;

                // Check for start condition
                if (totalActiveUsers > 0 && readyCount >= requiredReadyCount) {
                    if (player && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                        logStatus(`START CONDITION MET! Initiating video playback for all ${totalActiveUsers} users.`);
                        syncPlayerState(true, player.getCurrentTime());
                    }
                } else {
                    const needed = Math.max(0, requiredReadyCount - readyCount);
                    if (totalActiveUsers > 0) {
                        logStatus(`Waiting for ${needed} more user(s) to be ready... (${Math.ceil(READY_THRESHOLD_PERCENTAGE * 100)}% required)`);
                    } else {
                        logStatus(`Waiting for users to connect...`);
                    }
                }
            });
        }

        /**
         * Toggles the current user's local and remote readiness status.
         */
        async function toggleReady() {
            if (!currentUserRef) {
                logError("Authentication not complete. Cannot set ready status.");
                return;
            }
            isReady = !isReady;
            
            // Update local button appearance
            const readyBtn = getElement('readyButton');
            if (isReady) {
                readyBtn.textContent = 'Unready';
                readyBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                readyBtn.classList.add('bg-red-500', 'hover:bg-red-600');
            } else {
                readyBtn.textContent = 'I am Ready';
                readyBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                readyBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            }
            
            // Immediately update the remote status
            await setDoc(currentUserRef, { isReady: isReady }, { merge: true })
                .catch(err => logError("Failed to update ready status:", err));
        }


        // --- Player State Synchronization ---

        async function syncPlayerState(isPlaying, currentTime) {
            try {
                await setDoc(playerStateRef, {
                    isPlaying: isPlaying,
                    currentTime: currentTime,
                    updatedAt: serverTimestamp()
                });
                logStatus(isPlaying ? `Synced: PLAY at ${currentTime.toFixed(2)}s` : `Synced: PAUSE at ${currentTime.toFixed(2)}s`);
            } catch (e) {
                logError("Error synchronizing state: " + e);
            }
        }

        function setupFirestoreListener() {
            onSnapshot(playerStateRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    if (!player) return;

                    const playerState = player.getPlayerState();
                    const localTime = player.getCurrentTime();
                    
                    if (data.isPlaying) {
                        // If remote says PLAY
                        if (playerState !== YT.PlayerState.PLAYING && playerState !== YT.PlayerState.BUFFERING) {
                            player.playVideo();
                            logStatus(`Remote signal: Playing video.`);
                        }
                    } else {
                        // If remote says PAUSE
                        if (playerState !== YT.PlayerState.PAUSED) {
                            player.pauseVideo();
                            logStatus(`Remote signal: Pausing video.`);
                        }
                    }

                    // Seek synchronization (Tolerance for drift: 1 second)
                    if (Math.abs(localTime - data.currentTime) > 1.0) {
                        player.seekTo(data.currentTime, true);
                        logStatus(`Remote signal: Seeking to ${data.currentTime.toFixed(2)}s.`);
                    }
                } else {
                    logStatus("Firestore state document does not exist. Initializing state...");
                    // Initialize the state if it doesn't exist
                    setDoc(playerStateRef, { 
                        isPlaying: false, 
                        currentTime: 0, 
                        updatedAt: serverTimestamp() 
                    });
                }
            }, (error) => {
                logError(`Firestore Listener Error: ${error.message}`);
            });
        }

        // --- YouTube Player API ---

        let ytPlayerReady = false;

        window.onYouTubeIframeAPIReady = function() {
            ytPlayerReady = true;
            initializeApp(); // Initialize Firebase after YT API is ready
            
            player = new YT.Player('player', {
                height: '390',
                width: '640',
                videoId: 'MF58C9JJhJk', // <-- NEW VIDEO ID IS SET HERE
                playerVars: {
                    'controls': 0, // Custom controls
                    'disablekb': 1, // Disable keyboard controls
                    'modestbranding': 1,
                    'rel': 0, // No related videos
                    'showinfo': 0,
                    'enablejsapi': 1,
                    'origin': window.location.origin
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        };

        function onPlayerReady(event) {
            logStatus("YouTube Player is Ready. Awaiting Firebase connection...");
            // Hide the default play button overlay if it exists
            const playerOverlay = getElement('playerOverlay');
            if (playerOverlay) playerOverlay.style.display = 'none';
        }

        function onPlayerStateChange(event) {
            if (!auth || !auth.currentUser) return; // Ignore events if not authenticated
            
            const currentTime = player.getCurrentTime();
            const isPlaying = event.data === YT.PlayerState.PLAYING;
            const isPaused = event.data === YT.PlayerState.PAUSED;

            if (isPlaying) {
                // When playing, sync state (assuming the ready check already passed if it's external)
                // We always sync the state to Firestore when the player starts/stops
                syncPlayerState(true, currentTime);
            } else if (isPaused) {
                // When paused, sync state
                syncPlayerState(false, currentTime);
            }
            
            // Note: Seeking (YT.PlayerState.BUFFERING) is often ignored to prevent sync loops.
        }

        // --- Global functions for buttons ---
        window.toggleReady = toggleReady;
        window.syncPlayerState = syncPlayerState; // Expose for Sync button

        // Load the YouTube IFrame API asynchronously
        (function() {
            var tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        })();

        // Start Firebase initialization sequence when the YT API is ready (in window.onYouTubeIframeAPIReady)

    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container-card {
            max-width: 800px;
            margin: 40px auto;
            padding: 30px;
            background-color: #ffffff;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
        }
        .player-container {
            width: 100%;
            aspect-ratio: 16 / 9;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        #player {
            width: 100%;
            height: 100%;
        }
        .control-button {
            transition: all 0.2s ease-in-out;
            padding: 12px 24px;
            font-weight: 600;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        .control-button:active {
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1) inset;
            transform: translateY(1px);
        }
    </style>
</head>
<body>

<div class="container-card">
    <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b pb-2">
        Synchronized Audiobook Player
    </h1>

    <div id="messageBox">
        <!-- Error/Success messages will appear here -->
    </div>

    <div class="player-container mb-6">
        <div id="player"></div>
    </div>
    
    <div class="mb-6">
        <p id="statusText" class="text-gray-500 font-medium">Initializing...</p>
        <p class="text-gray-500 text-sm">Your ID (full string): <span id="userIdDisplay" class="font-mono bg-gray-100 px-1 rounded">Loading...</span></p>
    </div>

    <!-- New Readiness and Sync Controls -->
    <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
        
        <!-- READY STATUS -->
        <div class="flex-grow bg-blue-50 border border-blue-200 text-blue-700 px-4 py-3 rounded-lg shadow-inner flex items-center justify-between">
            <span class="font-semibold text-sm sm:text-base">Session Readiness:</span>
            <span id="readyStatus" class="text-lg font-extrabold">Ready: 0 / 0</span>
        </div>

        <!-- READY BUTTON -->
        <button id="readyButton" onclick="toggleReady()" class="control-button bg-green-500 text-white hover:bg-green-600 w-full sm:w-auto flex-shrink-0">
            I am Ready
        </button>
    </div>

    <!-- Synchronization Controls -->
    <div class="mt-6 pt-4 border-t">
        <h2 class="text-xl font-bold text-gray-700 mb-3">Sync Management (Host Use)</h2>
        <div class="flex flex-col space-y-3 sm:flex-row sm:space-y-0 sm:space-x-4">
            <button 
                onclick="syncPlayerState(player.getPlayerState() === YT.PlayerState.PLAYING, player.getCurrentTime())" 
                class="control-button bg-blue-500 text-white hover:bg-blue-600 w-full"
            >
                Synchronize (Send Current State)
            </button>
            <button 
                onclick="player.seekTo(0, true); syncPlayerState(false, 0);" 
                class="control-button bg-yellow-500 text-white hover:bg-yellow-600 w-full"
            >
                Reset to Start (0:00)
            </button>
        </div>
        <p class="text-xs text-gray-500 mt-2 italic">Note: Synchronization will be automatically sent when you hit Play/Pause.</p>
    </div>

    <div class="mt-6 pt-4 border-t">
        <h2 class="text-xl font-bold text-gray-700 mb-3">Video Link</h2>
        <p class="text-sm text-gray-600">The current video ID is: <span class="font-mono bg-gray-100 px-1 rounded">MF58C9JJhJk</span>.</p>
    </div>

    <footer class="mt-8 text-center text-xs text-gray-400">
        Multi-user synchronization via Firestore.
    </footer>
</div>

</body>
</html>
