<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synchronized Audiobook Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- ================================== CSS STYLES ================================== -->
    <style>
        /*
         * Base/Light Mode Colors (Default)
         */
        :root {
            --color-bg-body: #f3f4f6;
            --color-bg-card: #ffffff;
            --color-text-header: #1f2937; /* Gray 900 */
            --color-text-muted: #6b7280; /* Gray 500 */
            --color-border: #e5e7eb; /* Gray 200 */
            --color-status-text: #10b981; /* Green 500 */
        }
        
        /*
         * Dark Mode Colors
         */
        body.dark {
            --color-bg-body: #111827; /* Gray 900 */
            --color-bg-card: #1f2937; /* Gray 800 */
            --color-text-header: #f3f4f6; /* Gray 100 */
            --color-text-muted: #9ca3af; /* Gray 400 */
            --color-border: #374151; /* Gray 700 */
            --color-status-text: #34d399; /* Emerald 400 */
        }

        /* Applying the variables */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-body);
            transition: background-color 0.3s ease;
        }
        .container-card {
            max-width: 800px;
            margin: 40px auto;
            padding: 30px;
            background-color: var(--color-bg-card);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        .player-container {
            width: 100%;
            aspect-ratio: 16 / 9;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        #player {
            width: 100%;
            height: 100%;
        }
        .control-button {
            transition: all 0.2s ease-in-out;
            padding: 12px 24px;
            font-weight: 600;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        .control-button:active {
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1) inset;
            transform: translateY(1px);
        }
        
        /* Applying Text Colors via Tailwind/Variables */
        .text-3xl.font-extrabold, .text-xl.font-bold { color: var(--color-text-header); }
        .border-b, .border-t, .border { border-color: var(--color-border); }
        .text-gray-500, .text-gray-600 { color: var(--color-text-muted); }
        #statusText { color: var(--color-status-text) !important; }
        .bg-gray-100 { background-color: var(--color-border); color: var(--color-text-header); }
        
        /* Dark mode specific override for light status text */
        body.dark #statusText { color: var(--color-status-text) !important; }

    </style>
</head>
<body class="antialiased">

<div class="container-card">
    <div class="flex justify-between items-center mb-6 border-b pb-2">
        <h1 class="text-3xl font-extrabold">
            Synchronized Audiobook Player
        </h1>
        <!-- DARK MODE TOGGLE BUTTON -->
        <button id="darkModeToggle" class="p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-300 transition-colors duration-300 shadow-md hover:ring-2 ring-gray-500">
            <svg id="moonIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
            <svg id="sunIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.354 5.354l-.707-.707M5.354 5.354l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
        </button>
    </div>

    <div id="messageBox">
        <!-- Error/Success messages will appear here -->
    </div>

    <div class="player-container mb-6">
        <div id="player"></div>
    </div>
    
    <div class="mb-6">
        <p id="statusText" class="text-gray-500 font-medium">Initializing...</p>
        <p class="text-gray-500 text-sm">Your ID (full string): <span id="userIdDisplay" class="font-mono bg-gray-100 px-1 rounded">Loading...</span></p>
    </div>

    <!-- Group Control and Readiness -->
    <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
        
        <!-- READY STATUS DISPLAY -->
        <div class="flex-grow bg-blue-50 dark:bg-blue-900 border border-blue-200 dark:border-blue-700 text-blue-700 dark:text-blue-300 px-4 py-3 rounded-lg shadow-inner flex items-center justify-between">
            <span class="font-semibold text-sm sm:text-base">Online Users / Ready:</span>
            <span id="readyStatus" class="text-lg font-extrabold">Ready: 0 / 0</span>
        </div>

        <!-- READY BUTTON -->
        <button id="readyButton" class="control-button bg-green-500 text-white hover:bg-green-600 dark:hover:bg-green-700 w-full sm:w-auto flex-shrink-0">
            I am Ready
        </button>
        
    </div>
    
    <!-- Explicit Stop Control -->
    <div class="mt-4">
        <button 
            id="stopButton"
            class="control-button bg-red-500 text-white hover:bg-red-600 dark:hover:bg-red-700 w-full flex items-center justify-center"
        >
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            STOP Video for Everyone
        </button>
        <p class="text-xs text-gray-500 mt-2 italic text-center">This pauses and synchronizes the video state for all viewers.</p>
    </div>

    <!-- Synchronization Controls (Host Use) -->
    <div class="mt-6 pt-4 border-t">
        <h2 class="text-xl font-bold text-gray-700 mb-3">Host Controls (Manual Sync)</h2>
        <div class="flex flex-col space-y-3 sm:flex-row sm:space-y-0 sm:space-x-4">
            <button 
                id="syncButton"
                class="control-button bg-blue-500 text-white hover:bg-blue-600 dark:hover:bg-blue-700 w-full"
            >
                Manual Sync (Send Current Time/State)
            </button>
            <button 
                id="resetButton"
                class="control-button bg-yellow-500 text-white hover:bg-yellow-600 dark:hover:bg-yellow-700 w-full"
            >
                Reset to Start (0:00)
            </button>
        </div>
        <p class="text-xs text-gray-500 mt-2 italic">Note: The Play/Pause controls now only send sync signals, they don't auto-start based on readiness.</p>
    </div>

    <div class="mt-6 pt-4 border-t">
        <h2 class="text-xl font-bold text-gray-700 mb-3">Video Link</h2>
        <p class="text-sm text-gray-600">The current video ID is: <span class="font-mono bg-gray-100 px-1 rounded">MF58C9JJhJk</span>.</p>
    </div>

    <footer class="mt-8 text-center text-xs text-gray-400">
        Multi-user synchronization via Firestore.
    </footer>
</div>

<!-- ================================== JAVASCRIPT LOGIC ================================== -->
<script type="module">
    // Renaming the Firebase SDK function to avoid collision
    import { initializeApp as initializeFirebaseApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // --- Global State and Constants ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    
    // Fallback for external environments (MUST be updated by the user for external hosting)
    const EXTERNAL_FIREBASE_CONFIG = {
        apiKey: "AIzaSyC7eitj-tb2mHofXyJEHaegvNu_7EgXxxw",
        authDomain: "audiobookschoolofarhuron.firebaseapp.com",
        projectId: "audiobookschoolofarhuron",
        storageBucket: "audiobookschoolofarhuron.firebasestorage.app",
        messagingSenderId: "771527529225",
        appId: "1:771527529225:web:4f46a5bcc8008582e579d8"
    };

    const configToUse = firebaseConfig || EXTERNAL_FIREBASE_CONFIG;
    
    let app, db, auth, userId, player;
    let playerStateRef, usersRef, currentUserRef;

    let isReady = false; 
    const READY_THRESHOLD_PERCENTAGE = 0.5; 
    const INACTIVITY_TIMEOUT_MS = 15000; 

    // --- Utility Functions ---
    function getElement(id) {
        return document.getElementById(id);
    }

    function logError(message) {
        console.error(message);
        const messageBox = getElement('messageBox');
        messageBox.innerHTML = `<div class="bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-600 text-red-700 dark:text-red-300 px-4 py-3 rounded relative mb-4" role="alert">Error: ${message}</div>`;
    }

    function logStatus(message, isError = false) {
        console.log(message);
        const statusText = getElement('statusText');
        statusText.textContent = message;
        statusText.className = isError 
            ? 'text-red-600 font-semibold' 
            : 'text-green-600 font-semibold';
        // Tailwind class override for dark mode if needed, though CSS variables should handle it
        if (document.body.classList.contains('dark') && isError) {
             statusText.classList.remove('text-red-600');
             statusText.classList.add('text-red-400');
        } else if (!isError) {
             statusText.classList.remove('text-green-600');
             statusText.classList.add('text-green-500'); // Ensure status text is clearly visible in light mode
        }
    }
    
    // --- Dark Mode Logic ---

    function initializeDarkMode() {
        const isDark = localStorage.getItem('darkMode') === 'true';
        if (isDark) {
            document.body.classList.add('dark');
            updateDarkModeIcon(true);
        } else {
            document.body.classList.remove('dark');
            updateDarkModeIcon(false);
        }
    }
    
    function updateDarkModeIcon(isDark) {
        const sunIcon = getElement('sunIcon');
        const moonIcon = getElement('moonIcon');
        if (sunIcon && moonIcon) {
            sunIcon.style.display = isDark ? 'none' : 'block';
            moonIcon.style.display = isDark ? 'block' : 'none';
        }
    }

    function toggleDarkMode() {
        const isDark = document.body.classList.toggle('dark');
        localStorage.setItem('darkMode', isDark);
        updateDarkModeIcon(isDark);
    }


    // --- Firebase Initialization and Authentication ---
    async function initializeAppAndAuth() {
        // Log configuration check
        if (!configToUse || !configToUse.projectId || configToUse.projectId.includes("YOUR_PASTED")) {
            logError("CRITICAL: Firebase config missing or using placeholders. Cannot initialize.");
            return;
        }

        try {
            app = initializeFirebaseApp(configToUse); 
            db = getFirestore(app);
            auth = getAuth(app);

            // Set up Auth Listener
            await auth.signOut(); // Ensure fresh state if environment reloads without full clear
            await signInAnonymously(auth);
            
            auth.onAuthStateChanged((user) => {
                if (user) {
                    userId = user.uid;
                    getElement('userIdDisplay').textContent = userId; 
                    logStatus(`Authenticated: User ID ${userId.substring(0, 8)}...`);
                    
                    setupFirestoreReferences();
                    setupFirestoreListener();
                    monitorUserPresence(); 
                    listenToReadyStatus();
                    
                } else {
                    logStatus("Authentication failed. Check Firebase console for Anonymous Sign-in status.", true);
                }
            });
        } catch (error) {
            logError(`Firebase Init Error: ${error.message}`);
        }
    }

    function setupFirestoreReferences() {
        if (!auth.currentUser) return; 

        const playerStateDocPath = `artifacts/${appId}/public/data/audiobook_player_state/state`;
        playerStateRef = doc(db, playerStateDocPath);

        const usersCollectionPath = `artifacts/${appId}/public/data/audiobook_users`;
        usersRef = collection(db, usersCollectionPath);
        
        currentUserRef = doc(db, usersCollectionPath, auth.currentUser.uid);
    }

    // --- User Presence and Readiness ---

    /** Updates the current user's lastSeen timestamp and isReady status. */
    function monitorUserPresence() {
        const updatePresence = () => {
            if (!currentUserRef) return; 
            setDoc(currentUserRef, {
                isReady: isReady,
                lastSeen: serverTimestamp()
            }, { merge: true })
            .catch(err => console.error("Error updating user presence:", err));
        };

        updatePresence(); 
        setInterval(updatePresence, INACTIVITY_TIMEOUT_MS / 3); 
    }

    /** Listens to all user documents to calculate total active and ready users. */
    function listenToReadyStatus() {
        const cutoff = new Date(Date.now() - INACTIVITY_TIMEOUT_MS);
        
        onSnapshot(usersRef, (snapshot) => {
            let readyCount = 0;
            let totalActiveUsers = 0;
            const currentUserId = auth.currentUser ? auth.currentUser.uid : null;
            
            snapshot.forEach(userDoc => {
                const data = userDoc.data();
                let isUserActive = false;
                
                // 1. Check if the user has been seen recently
                if (data.lastSeen) {
                    const lastSeenMs = data.lastSeen.toMillis();
                    if (lastSeenMs >= cutoff.getTime()) {
                        isUserActive = true;
                    }
                } 
                // 2. If no timestamp, count the current user to ensure 1/1 visibility
                else if (userDoc.id === currentUserId) {
                    isUserActive = true; 
                }

                if (isUserActive) {
                    totalActiveUsers++;
                    if (data.isReady) {
                        readyCount++;
                    }
                }
            });
            
            const requiredReadyCount = Math.ceil(totalActiveUsers * READY_THRESHOLD_PERCENTAGE);
            
            // Update the ready status display
            getElement('readyStatus').textContent = `Ready: ${readyCount} / ${totalActiveUsers}`;

            // --- STRICT READY-START LOGIC ---
            if (totalActiveUsers > 0 && readyCount >= requiredReadyCount) {
                // If the ready threshold is met, send the PLAY signal
                if (player && player.getPlayerState() !== YT.PlayerState.PLAYING) { 
                    logStatus(`Ready threshold met: Initiating video playback!`);
                    // Send the PLAY signal
                    syncPlayerState(true, player.getCurrentTime() || 0); 
                }
            } else {
                const needed = Math.max(0, requiredReadyCount - readyCount);
                if (totalActiveUsers > 0) {
                    logStatus(`Waiting for ${needed} more user(s) to be ready... (${Math.ceil(READY_THRESHOLD_PERCENTAGE * 100)}% required)`);
                } else {
                    logStatus(`Waiting for users to connect...`);
                }
            }
        });
    }

    /** Toggles the current user's local and remote readiness status. */
    function toggleReady() {
        if (!currentUserRef) {
            logError("Authentication not complete. Cannot set ready status.");
            return;
        }
        isReady = !isReady;
        
        const readyBtn = getElement('readyButton');
        if (isReady) {
            readyBtn.textContent = 'Unready';
            readyBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
            readyBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'dark:hover:bg-red-700');
        } else {
            readyBtn.textContent = 'I am Ready';
            readyBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'dark:hover:bg-red-700');
            readyBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'dark:hover:bg-green-700');
        }
        
        setDoc(currentUserRef, { isReady: isReady }, { merge: true })
            .catch(err => logError("Failed to update ready status:", err));
    }


    // --- Player State Synchronization ---

    /** Sends player state (playing/paused and current time) to Firestore. */
    function syncPlayerState(isPlaying, currentTime) {
        if (!playerStateRef) {
            logError("Firestore references not set. Cannot synchronize state.");
            return;
        }
        try {
            setDoc(playerStateRef, {
                isPlaying: isPlaying,
                currentTime: currentTime,
                updatedAt: serverTimestamp()
            });
            logStatus(isPlaying ? `Synced: PLAY at ${currentTime.toFixed(2)}s` : `Synced: PAUSE at ${currentTime.toFixed(2)}s`);
        } catch (e) {
            logError("Error synchronizing state: " + e);
        }
    }

    function setupFirestoreListener() {
        if (!playerStateRef) return; 

        onSnapshot(playerStateRef, (docSnapshot) => {
            if (docSnapshot.exists()) {
                const data = docSnapshot.data();
                if (!player || !player.getPlayerState) return;

                const playerState = player.getPlayerState();
                const localTime = player.getCurrentTime();
                
                // Handle Play/Pause
                if (data.isPlaying) {
                    if (player.playVideo && playerState !== YT.PlayerState.PLAYING && playerState !== YT.PlayerState.BUFFERING) {
                        player.playVideo();
                        logStatus(`Remote signal: Playing video.`);
                    }
                } else {
                    if (player.pauseVideo && playerState !== YT.PlayerState.PAUSED) {
                        player.pauseVideo();
                        logStatus(`Remote signal: Pausing video.`);
                    }
                }

                // Seek synchronization (Tolerance for drift: 1 second)
                if (player.seekTo && Math.abs(localTime - data.currentTime) > 1.0) {
                    player.seekTo(data.currentTime, true);
                    logStatus(`Remote signal: Seeking to ${data.currentTime.toFixed(2)}s.`);
                }
            } else {
                logStatus("Firestore state document does not exist. Initializing state...");
                // Initialize the state if it doesn't exist
                setDoc(playerStateRef, { 
                    isPlaying: false, 
                    currentTime: 0, 
                    updatedAt: serverTimestamp() 
                });
            }
        }, (error) => {
            logError(`Firestore Listener Error: ${error.message}`);
        });
    }

    // --- YouTube Player API ---

    window.onYouTubeIframeAPIReady = function() {
        initializeAppAndAuth(); 
        
        player = new YT.Player('player', {
            height: '390',
            width: '640',
            videoId: 'MF58C9JJhJk', 
            playerVars: {
                'controls': 0, // IMPORTANT: Controls are now hidden to enforce app-level synchronization
                'disablekb': 1, 
                'modestbranding': 1,
                'rel': 0, 
                'showinfo': 0,
                'enablejsapi': 1,
                'origin': window.location.origin
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    };

    function onPlayerReady(event) {
        logStatus("YouTube Player is Ready. Awaiting Firebase connection...");
    }

    /** * Handles state changes from the local player (e.g., user clicked play/pause on the video frame).
     * This now sends a sync signal ONLY if the state is Play or Pause.
     * The auto-start logic is strictly handled by listenToReadyStatus.
     */
    function onPlayerStateChange(event) {
        if (!auth || !auth.currentUser) return; 
        
        const currentTime = player.getCurrentTime();
        const isPlaying = event.data === YT.PlayerState.PLAYING;
        const isPaused = event.data === YT.PlayerState.PAUSED;

        // Only sync if the state is explicitly PLAYING or PAUSED due to a user interaction
        if (isPlaying || isPaused) {
            syncPlayerState(isPlaying, currentTime);
        }
    }

    // --- Global Helpers for Manual Button Actions ---

    // 1. Safely sends current state to Firestore
    function sendCurrentState() {
        if (!player || !player.getPlayerState) {
            logStatus("Player not ready to send state.", true);
            return;
        }
        const isPlaying = player.getPlayerState() === YT.PlayerState.PLAYING;
        const currentTime = player.getCurrentTime() || 0;
        syncPlayerState(isPlaying, currentTime);
    }
    
    // 2. Forces the player to stop/pause for everyone
    function stopPlayerState() {
        if (!player || !player.pauseVideo) {
            logStatus("Player not ready to stop.", true);
            return;
        }
        // Pause locally
        player.pauseVideo();
        // Send PAUSED state to Firestore
        syncPlayerState(false, player.getCurrentTime() || 0);
        logStatus("Video forcefully stopped and synchronized for all users.");
    }
    
    // 3. Resets and synchronizes to time 0
    function resetPlayerState() {
        if (!player || !player.seekTo) {
            logStatus("Player API is not fully ready for seeking (Reset failed).", true);
            return;
        }
        player.seekTo(0, true); 
        syncPlayerState(false, 0);
        logStatus("Video reset to 0:00 and paused.");
    }
    
    // --- Global exposure and Event Binding ---
    
    window.toggleReady = toggleReady;
    window.sendCurrentState = sendCurrentState; 
    window.stopPlayerState = stopPlayerState; // Exposed stop function
    window.resetPlayerState = resetPlayerState;
    window.toggleDarkMode = toggleDarkMode; 

    // Attach listeners after the DOM is ready to ensure the elements and functions exist
    document.addEventListener('DOMContentLoaded', () => {
        initializeDarkMode(); 

        getElement('readyButton')?.addEventListener('click', window.toggleReady);
        getElement('syncButton')?.addEventListener('click', window.sendCurrentState);
        getElement('stopButton')?.addEventListener('click', window.stopPlayerState); // New Stop button listener
        getElement('resetButton')?.addEventListener('click', window.resetPlayerState);
        getElement('darkModeToggle')?.addEventListener('click', window.toggleDarkMode);
    });


    // Load the YouTube IFrame API asynchronously
    (function() {
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    })();

</script>

</body>
</html>
